/**
 * swr - a software rasterizer
 *
 * vertex definition.
 *
 * \author Felix Lubbe
 * \copyright Copyright (c) 2021
 * \license Distributed under the MIT software license (see accompanying LICENSE.txt).
 */

#pragma once

#include <boost/container/static_vector.hpp>

namespace geom
{

/** possible flags associated to a vertex. */
enum vertex_flags : std::uint32_t
{
    vf_none = 0,           /** no vertex flags set. */
    vf_line_strip_end = 1, /** this is the last vertex in a line strip. */
    vf_clip_discard = 2,   /** this vertex does not lie inside the view volume. */
    vf_interpolated = 4    /** this vertex was generated by interpolation. */
};

/** Vertex format. */
struct vertex
{
    /**
     * coordinates at different stages of the pipeline.
     *
     * depending on the pipeline stage, these may contain any of:
     *  *) the vertex position relative
     *  *) the homogeneous clip coordinates
     *  *) the viewport coordinates
     */
    ml::vec4 coords;

    /** varyings. these are the vertex shader outputs. */
    boost::container::static_vector<ml::vec4, limits::max::varyings> varyings;

    /** vertex flags. */
    std::uint32_t flags{vf_none};
};

/**
 * Linear interpolate vertex data in clipping stage. This occurs after the vertex shader has been called,
 * so that we also interpolate vertex shader outputs (i.e., varyings).
 *
 * Interpolated data:
 *  *) clip coordinates
 *  *) varyings
 *
 * @param t Interpolation parameter.
 * @param v1 First vertex for interpolation.
 * @param v2 Second vertex for interpolation.
 * @returns Returns a vertex with interpolated coordinates and varyings.
 */
inline vertex lerp(
  float t,
  const vertex& v1,
  const vertex& v2)
{
    vertex r{
      .coords = ml::lerp(t, v1.coords, v2.coords),
      .flags = vf_interpolated};

    // interpolate varyings
    for(std::size_t i = 0; i < v1.varyings.size(); ++i)
    {
        r.varyings.emplace_back(ml::lerp(t, v1.varyings[i], v2.varyings[i]));
    }

    return r;
}

} /* namespace geom */